# Copyright 2022 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import json

from datetime import datetime
from .base_result_summary import (BaseResultSummary, TestStatus, TestResult,
                                  TestResultErrorMessageRegexSimilarityMixin)


class GTestTestResult(TestResultErrorMessageRegexSimilarityMixin, TestResult):
  pass

# https://source.chromium.org/chromium/infra/infra/+/main:go/src/infra/tools/result_adapter/gtest.go;l=277;drc=6cc18e2763e180929d70c786b419c1f8e6bcc66c
GTEST_STATUS_MAP = {
    'SUCCESS': TestStatus.PASS,
    'FAILURE': TestStatus.FAIL,
    'FAILURE_ON_EXIT': TestStatus.FAIL,
    'TIMEOUT': TestStatus.ABORT,
    'CRASH': TestStatus.CRASH,
    'SKIPPED': TestStatus.SKIP,
    'EXCESSIVE_OUTPUT': TestStatus.FAIL,
    'NOTRUN': TestStatus.SKIP,
    'UNKNOWN': TestStatus.ABORT,
}

GTEST_EXPECTED_STATUS = ('SUCCESS', 'SKIPPED')


def parse_status(status_str):
  return GTEST_STATUS_MAP.get(status_str, TestStatus.STATUS_UNSPECIFIED)


def is_expected_status(status_str):
  return status_str in GTEST_EXPECTED_STATUS


# https://source.chromium.org/chromium/infra/infra/+/main:go/src/infra/tools/result_adapter/gtest.go;l=379;drc=6cc18e2763e180929d70c786b419c1f8e6bcc66c
# The result_adapter implementation uses summary_base64. Since we use the
# summary message for comparison (if the failure is similar), the encoding
# doesn't matter. We use summary for simplicity.
def extract_primary_error_message(result_parts):
  primary_error_message = None
  for part in result_parts:
    if part.get('type') in ('success', 'failure'):
      primary_error_message = part.get('summary')
    elif part.get('type') == 'fatal_failure':
      return part.get('summary')
  return primary_error_message


def parse_timestamp(time_str):
  if not time_str:
    return None
  # Convert to python supported ISO 8601 format.
  if time_str.endswith('Z'):
    time_str = time_str[:-1] + '+00:00'
  return int(datetime.fromisoformat(time_str).timestamp())


class GTestTestResultSummary(BaseResultSummary):
  FORMAT_ERROR = ValueError(
      'Not supported GTest output format. ',
      'Please make sure the output.json is generated by '
      '--test-launcher-summary-output')

  def __init__(self):
    super().__init__()
    self._raw_data = None

  @classmethod
  def from_output_json(cls, json_data):
    if not isinstance(json_data, dict) \
      or 'per_iteration_data' not in json_data \
      or not isinstance(json_data['per_iteration_data'], list):
      raise cls.FORMAT_ERROR

    result = cls()
    result._raw_data = json_data
    for iteration in json_data['per_iteration_data']:
      if not isinstance(iteration, dict):
        raise cls.FORMAT_ERROR
      for test_name, runs in iteration.items():
        for run in runs:
          result.add(
              GTestTestResult(
                  test_name,
                  expected=is_expected_status(run.get('status')),
                  status=parse_status(run.get('status')),
                  primary_error_message=extract_primary_error_message(
                      run.get('result_parts', [])),
                  start_time=parse_timestamp(run.get('timestamp')),
                  duration=run.get('elapsed_time_ms'),
                  batch_id=run.get('process_num'),
                  thread_id=run.get('thread_id'),
              ))
    return result

  def dump_raw_data(self):
    return json.dumps(self._raw_data)

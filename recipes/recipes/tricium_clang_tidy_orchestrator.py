# Copyright 2022 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import itertools
import json
from typing import Any, Dict, List, NamedTuple, Tuple

from PB.go.chromium.org.luci.buildbucket.proto import common as common_pb2
from recipe_engine import post_process

PYTHON_VERSION_COMPATIBILITY = "PY3"

DEPS = [
    'chromium',
    'depot_tools/gerrit',
    'depot_tools/tryserver',
    'recipe_engine/buildbucket',
    'recipe_engine/json',
    'recipe_engine/platform',
    'recipe_engine/step',
    'recipe_engine/swarming',
    'recipe_engine/tricium',
]

# TODO(crbug.com/1153919): Figure out which subset of these are the best
# trade-off between coverage/cost and enable them.
_CHILD_BUILDERS = (
    'android-clang-tidy-rel',
    'linux-chromeos-clang-tidy-rel',
    'linux-clang-tidy-rel',
    #'linux-lacros-clang-tidy-rel',
    #'fuchsia-clang-tidy-rel',
    #'ios-clang-tidy-rel',
    #'mac-clang-tidy-rel',
    #'win10-clang-tidy-rel',
)

# This is a comment emitted by tricium. The intent is for it to have all of the
# information that can possibly be passed to api.tricium.add_comment.
_TriciumComment = NamedTuple(
    '_TriciumComment',
    (
        ('category', str),
        ('message', str),
        ('path', str),
        ('start_line', int),
        ('end_line', int),
        ('start_char', int),
        ('end_char', int),
        ('suggestions', Dict[str, Any]),
    ),
)


def _build_tricium_comment_with_defaults(category,
                                         message,
                                         path,
                                         start_line=0,
                                         end_line=0,
                                         start_char=0,
                                         end_char=0,
                                         suggestions=()):
  return _TriciumComment(category, message, path, start_line, end_line,
                         start_char, end_char, suggestions)


def _parse_comments_from_json_list(json_list):
  # Go's protobuf package outputs camelCase JSON, whereas Python prefers
  # snake_case; handle that transformation here.
  key_transformations = {
      'startLine': 'start_line',
      'endLine': 'end_line',
      'startChar': 'start_char',
      'endChar': 'end_char',
  }

  results = []
  for x in json_list:
    x = {key_transformations.get(k, k): v for k, v in x.items()}
    results.append(_build_tricium_comment_with_defaults(**x))
  return results


def _should_skip_linting(api):
  revision_info = api.gerrit.get_revision_info(
      'https://%s' % api.tryserver.gerrit_change.host,
      api.tryserver.gerrit_change.change, api.tryserver.gerrit_change.patchset)

  # TODO(gbiv): It may be nice to be more consistent in how we check for
  # whether something's lintable. At the time of writing, this heuristic is
  # what's being used for linux-clang-tidy-rel's recipe, but:
  # - tricium_simple does something different entirely
  # - this heuristic doesn't perfectly cover all reverts
  # - it'd be nice to skip autogenerated CLs entirely (crbug.com/872381)
  commit_message = revision_info['commit']['message']
  return commit_message.startswith('Revert')


def _note_observed_on(platforms, all_platforms, lint):
  backquote = lambda s: '`%s`' % s

  msg = 'Lint observed on ' + ', '.join(backquote(x) for x in platforms)
  platforms_set = set(platforms)
  not_observed_on = ', '.join(
      backquote(p) for p in all_platforms if p not in platforms_set)
  if not_observed_on:
    msg += ', but not on ' + not_observed_on

  return lint._replace(message=lint.message + '\n\n(%s)' % msg)


def _dedup_and_fixup_tricium_lints(all_platforms, lints):
  merged_lints = []
  for platform, platform_lints in lints.items():
    for l in platform_lints:
      merged_lints.append((l, platform))

  # _TriciumComments contain data which is unhashable, but comparable. While
  # the comparison order may not always be intuitive, we don't care; it's
  # deterministic, and we only ultimately care about having identical lints
  # placed adjacent to each other, so we may deduplicate them in < n^2 time.
  merged_lints.sort()

  results = []
  for lint, items in itertools.groupby(merged_lints, lambda x: x[0]):
    observed_on = [x for _, x in items]
    results.append(_note_observed_on(observed_on, all_platforms, lint))
  return results


def RunSteps(api):
  assert api.tryserver.is_tryserver

  if _should_skip_linting(api):
    return

  with api.step.nest('schedule tidy builds'):
    build_requests = [
        api.buildbucket.schedule_request(
            x,
            swarming_parent_run_id=api.swarming.task_id,
            tags=api.buildbucket.tags(**{'hide-in-gerrit': 'true'}),
        ) for x in _CHILD_BUILDERS
    ]
    builds = api.buildbucket.schedule(build_requests, step_name='schedule')
    build_ids = [x.id for x in builds]
    build_dict = api.buildbucket.collect_builds(
        build_ids,
        fields=('output', 'status'),
    )

    num_failures = sum(
        1 for x in build_dict.values() if x.status != common_pb2.SUCCESS)
    had_failures = num_failures != 0
    all_failures = num_failures == len(builds)

    if had_failures:
      presentation = api.step.active_result.presentation
      presentation.status = api.step.WARNING
      presentation.step_text = "%d/%d builds failed" % (num_failures,
                                                        len(builds))

    builds = [(x, build_dict[i]) for x, i in zip(_CHILD_BUILDERS, build_ids)]

  with api.step.nest('analyze lints'):
    lints = {}
    for builder_name, build_result in builds:
      properties = build_result.output.properties
      if 'tricium' not in properties:
        continue

      comments = json.loads(properties['tricium']).get('comments', ())
      lints[builder_name] = _parse_comments_from_json_list(comments)

    tricium_lints = _dedup_and_fixup_tricium_lints(_CHILD_BUILDERS, lints)

  with api.step.nest('emit comments'):
    for lint in tricium_lints:
      api.tricium.add_comment(**lint._asdict())
    api.tricium.write_comments()

  if all_failures:
    raise api.step.InfraFailure('all sub-linting tasks failed')


def _get_tricium_comments(steps):
  write_results = steps['emit comments.write results']
  tricium_json = write_results.output_properties['tricium']
  comments = json.loads(tricium_json).get('comments')
  if comments:
    comments = _parse_comments_from_json_list(comments)
  return comments


def _tricium_has_no_comments(check, steps):
  comments = _get_tricium_comments(steps)
  check(not comments)


def _tricium_has_comment(check, steps, comment):
  comments = _get_tricium_comments(steps)
  check(comments)
  if comments:
    check(comment in comments)


def GenTests(api):

  def test(name, tricium_data, bot_status_overrides=None, commit_message='foo'):

    def make_test(*overrides):
      return api.test(
          name,
          api.chromium.try_build(
              builder_group='tryserver.chromium.linux',
              builder='linux_chromium_compile_rel_ng',
              build_number=1234,
              patch_set=1), api.platform('linux', 64),
          api.override_step_data(
              'gerrit changes',
              api.json.output([{
                  'revisions': {
                      'a' * 40: {
                          '_number': 1,
                          'commit': {
                              'author': {
                                  'email': 'gbiv@google.com',
                              },
                              'message': commit_message,
                          }
                      }
                  }
              }])), *overrides)

    if commit_message.startswith('Revert'):
      return make_test()

    if bot_status_overrides is None:
      bot_status_overrides = {}

    # Magic unexported number from buildbucket/api.py; test build IDs are
    # generated sequentially from this, and there're a few other recipes that
    # depend on this number directly.
    base_id = 8922054662172514000
    build_ids = list(range(base_id, base_id + len(_CHILD_BUILDERS)))
    build_output = [
        api.buildbucket.try_build_message(
            build_id=i,
            status=bot_status_overrides.get(builder_name, 'SUCCESS'),
        ) for i, builder_name in zip(build_ids, _CHILD_BUILDERS)
    ]

    if tricium_data is not None:
      builder_indices = {n: i for i, n in enumerate(_CHILD_BUILDERS)}
      for builder_name, comments in tricium_data.items():
        n = builder_indices[builder_name]
        tricium_section = {}
        if comments:
          tricium_section['comments'] = [x._asdict() for x in comments]
        build_output[n].output.properties['tricium'] = api.json.dumps(
            tricium_section)

    return make_test(
        api.buildbucket.simulated_collect_output(
            build_output,
            step_name='schedule tidy builds.buildbucket.collect',
        ))

  yield (
      test('skip_reverted_cl', tricium_data=None, commit_message='Revert foo') +
      api.post_process(post_process.StatusSuccess) +
      api.post_process(post_process.DoesNotRun, 'schedule tidy builds') +
      api.post_process(post_process.DropExpectation))

  yield (test('success_on_no_tricium_output', tricium_data=None) +
         api.post_process(post_process.StatusSuccess) +
         api.post_process(_tricium_has_no_comments) +
         api.post_process(post_process.DropExpectation))

  yield (test(
      'success_on_empty_tricium_output',
      tricium_data={name: [] for name in _CHILD_BUILDERS}) +
         api.post_process(post_process.StatusSuccess) +
         api.post_process(_tricium_has_no_comments) +
         api.post_process(post_process.DropExpectation))

  comment0 = _build_tricium_comment_with_defaults(
      category='some category',
      message='some message',
      path='foo.cpp',
  )
  yield (test(
      'basic_tidy_output_works', tricium_data={_CHILD_BUILDERS[0]: [comment0]})
         + api.post_process(post_process.StatusSuccess) + api.post_process(
             _tricium_has_comment,
             _note_observed_on([_CHILD_BUILDERS[0]], _CHILD_BUILDERS, comment0))
         + api.post_process(post_process.DropExpectation))

  yield (test(
      'multibot_tidy_output_works',
      tricium_data={
          _CHILD_BUILDERS[0]: [comment0],
          _CHILD_BUILDERS[1]: [comment0],
      }) + api.post_process(post_process.StatusSuccess) + api.post_process(
          _tricium_has_comment,
          _note_observed_on([_CHILD_BUILDERS[0], _CHILD_BUILDERS[1]],
                            _CHILD_BUILDERS, comment0)) +
         api.post_process(post_process.DropExpectation))

  comment1 = _build_tricium_comment_with_defaults(
      category='some other category',
      message='some other message',
      path='foo2.cpp',
      suggestions=[{
          'description':
              'foo',
          'replacements': [{
              'path': '/path/to/foo.cc',
              'replacement': 'replaced',
          }],
      }],
  )
  yield (test(
      'multibot_multicomment_tidy_output_works',
      tricium_data={
          _CHILD_BUILDERS[0]: [comment0],
          _CHILD_BUILDERS[1]: [comment0, comment1],
      }) + api.post_process(post_process.StatusSuccess) + api.post_process(
          _tricium_has_comment,
          _note_observed_on([_CHILD_BUILDERS[0], _CHILD_BUILDERS[1]],
                            _CHILD_BUILDERS, comment0),
      ) + api.post_process(
          _tricium_has_comment,
          _note_observed_on([_CHILD_BUILDERS[1]], _CHILD_BUILDERS, comment1),
      ) + api.post_process(post_process.DropExpectation))

  infra_failure = 'INFRA_FAILURE'
  yield (test(
      'single_bot_failure',
      bot_status_overrides={
          _CHILD_BUILDERS[0]: infra_failure,
      },
      tricium_data={
          _CHILD_BUILDERS[0]: [comment0],
          _CHILD_BUILDERS[1]: [comment0],
      }) + api.post_process(post_process.StatusSuccess) +
         api.post_process(post_process.StepWarning, 'schedule tidy builds') +
         api.post_process(
             _tricium_has_comment,
             _note_observed_on([_CHILD_BUILDERS[0], _CHILD_BUILDERS[1]],
                               _CHILD_BUILDERS, comment0),
         ) + api.post_process(post_process.DropExpectation))

  yield (test(
      'all_bot_failure',
      bot_status_overrides={
          builder: infra_failure for builder in _CHILD_BUILDERS
      },
      tricium_data={builder: [comment0] for builder in _CHILD_BUILDERS}) +
         api.post_process(post_process.StatusException) +
         api.post_process(post_process.StepWarning, 'schedule tidy builds') +
         api.post_process(
             _tricium_has_comment,
             _note_observed_on(_CHILD_BUILDERS, _CHILD_BUILDERS, comment0),
         ) + api.post_process(post_process.DropExpectation))

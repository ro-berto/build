#!/usr/bin/env python
# Copyright (c) 2012 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Given a list of manifest, print a dictionary mapping them
to their hash values.
"""

import hashlib
import json
import optparse
import os
import sys

from slave import build_directory

def main():
  # Parses arguments
  parser = optparse.OptionParser(usage='%prog [options]')
  parser.add_option('-n', '--manifest_name', action='append', default=[],
                    help='The name of a manifest to send to swarm. This may '
                         'be given multiple times to send multiple manifests.')
  parser.add_option('--build-dir', help='ignored')
  parser.add_option('--target', help='Release or Debug')
  parser.add_option('--output-json',
                    help='File to dump JSON results into. '
                    'If unspecified, writes to stdout.')
  (options, args) = parser.parse_args()

  assert options.target
  build_dir = build_directory.GetBuildOutputDirectory()
  manifest_directory = os.path.join(build_dir, options.target)

  manifests = options.manifest_name

  # Treat all arguments as 'test:test_filter'.
  for arg in args:
    # The buildbot might have put multiple test:test_filter pairs in a single
    # argument so split them up and add them separately.
    tests = arg.split()
    for test in tests:
      test_name = test.split(':', 1)[0] if ':' in test else test
      manifests.append(test_name + '.isolated')

  names_and_hashes = {}

  # Get the file hash values and output the pair.
  for filepath in manifests:
    test_name = os.path.basename(filepath).split('.')[0]
    full_filepath = os.path.join(manifest_directory, filepath)

    if not os.path.exists(full_filepath):
      print 'The manifest, %s, doesn\'t exist' % full_filepath
      continue

    sha1_hash = hashlib.sha1(open(full_filepath, 'rb').read()).hexdigest()
    names_and_hashes[test_name] = sha1_hash
    if not options.output_json:
      print test_name + ' ' + sha1_hash

      # TODO(csharp): Remove both the message and the deletion once the
      # isolate tracked dependencies are inputs for the isolated files.
      print ('Delete %s to ensure it is regenerated by the next build.' %
             full_filepath)
    os.remove(full_filepath)

  if options.output_json:
    with open(options.output_json, 'w') as f:
      json.dump(names_and_hashes, f)

if __name__ == '__main__':
  sys.exit(main())

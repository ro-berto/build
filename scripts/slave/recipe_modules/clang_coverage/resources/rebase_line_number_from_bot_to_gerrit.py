#!/usr/bin/python
# Copyright 2018 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
"""This script generates the line number mapping from bot to Gerrit.

For example:

On Gerrit, 'test.txt' is generated by applying my change to base revision 10:
#1: line 1
#2: line 2, changed by me
#3: line 3

On the bot, 'test.txt' is generated by applying my change to base revision 12:
#1: line 0, added by someone else
#2: line 1, changed by someone else
#3: line 2, changed by me

After rebasing the line numbers, we'd like understand that
'line 2, changed by me' exists in both files (it should, because both two files
contain my change), and their line number mapping is 2 -> 3.
"""

import argparse
import json
import logging
import os
import sys
import tempfile

import gerrit_util


def rebase_line_number(host, project, change, patchset, src_path, sources):
  """Rebases line number for a list of files from bot to gerrit.

  Args:
    host (str): The url of the Gerrit host.
    project (str): The Gerrit project name.
    change (int): The Gerrit change number.
    patchset (int): The Gerrit patchset number.
    src_path (str): Absoluate path to the root of the checkout.
    sources (list): A list of relative path to the source files.

  Returns:
    A map whose key is a file name that is relative to the root of the checkout,
    and the corresponding value is another map that maps from local file's line
    number to Gerrit file's line number as well as the line itself.
  """
  gerrit_files_content = gerrit_util.fetch_files_content(
      host, project, change, patchset, sources)

  file_to_line_num_mapping = {}
  for i in range(len(sources)):
    abs_local_file_path = os.path.join(src_path, sources[i])
    if not os.path.isfile(abs_local_file_path):
      logging.info(
          'File "%s" does not exist in the checkout because it is '
          'deleted by the patch', sources[i])
      continue

    gerrit_file = tempfile.NamedTemporaryFile()
    gerrit_file.write(gerrit_files_content[i])
    gerrit_file.flush()

    file_to_line_num_mapping[
        sources[i]] = gerrit_util.generate_line_number_mapping(
            abs_local_file_path, gerrit_file.name)
    gerrit_file.close()

  return file_to_line_num_mapping


def _parse_args():
  arg_parser = argparse.ArgumentParser()
  arg_parser.usage = __doc__

  arg_parser.add_argument(
      '--host', required=True, type=str, help='The url of the Gerrit host.')

  arg_parser.add_argument(
      '--project', required=True, type=str, help='The Gerrit project name')

  arg_parser.add_argument(
      '--change', required=True, type=int, help='The Gerrit change number.')

  arg_parser.add_argument(
      '--patchset', required=True, type=int, help='The Gerrit patchset number.')

  arg_parser.add_argument(
      '--src-path',
      required=True,
      type=str,
      help='absolute path to the root of the checkout')

  arg_parser.add_argument(
      '--output-file',
      required=True,
      type=str,
      help='Path to a file where the line number mapping is written to, and '
      'the format of the mapping is a map whose key is a file name that is '
      'relative to the root of the checkout, and the corresponding value is '
      'another map that maps from local file\'s line number to Gerrit file\'s '
      'line number as well as the line itself.')

  arg_parser.add_argument(
      'sources',
      nargs='+',
      help='Paths of source files to line number mapping for, the paths are '
      'relative to the root of the checkout, with platform-specific path '
      'separator.')

  return arg_parser.parse_args()


# TODO(crbug.com/927941): Remove once the Gerrit side fix is live in prod.
def _filter_out_unchanged_lines(file_to_line_num_mapping, host, project, change,
                                patchset):
  gerrit_diff = gerrit_util.fetch_diff(host, project, change, patchset)
  file_to_added_lines = gerrit_util.parse_added_line_num_from_git_diff(
      gerrit_diff.splitlines())

  filtered_file_to_line_num_mapping = {}
  for file_path in file_to_line_num_mapping:
    if file_path not in file_to_added_lines:
      filtered_file_to_line_num_mapping[file_path] = {}
      continue

    filtered_file_to_line_num_mapping[file_path] = {}
    for bot_line_num in file_to_line_num_mapping[file_path]:
      gerrit_line_num, line = file_to_line_num_mapping[file_path][bot_line_num]
      if gerrit_line_num in file_to_added_lines[file_path]:
        filtered_file_to_line_num_mapping[file_path][bot_line_num] = (
            gerrit_line_num, line)

  return filtered_file_to_line_num_mapping


def main():
  args = _parse_args()

  logging.basicConfig(
      level=logging.INFO, format='[%(asctime)s %(levelname)s] %(message)s')
  if not os.path.isdir(args.src_path):
    raise RuntimeError('Checkout: "%s" doesn\'t exist.' % args.src_path)

  file_to_line_num_mapping = rebase_line_number(args.host, args.project,
                                                args.change, args.patchset,
                                                args.src_path, args.sources)
  file_to_line_num_mapping = _filter_out_unchanged_lines(
      file_to_line_num_mapping, args.host, args.project, args.change,
      args.patchset)
  with open(args.output_file, 'w') as f:
    json.dump(file_to_line_num_mapping, f)


if __name__ == '__main__':
  sys.exit(main())

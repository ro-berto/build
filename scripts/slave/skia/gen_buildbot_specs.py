#!/usr/bin/env python
#
# Copyright 2015 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.


'''Generate buildbot specs for all buildbots.'''


import datetime
import json
import os
import re
import subprocess
import sys
import tempfile


# These are the bots which are run by the recipe simulation tests.
bots = [
    'Build-Mac10.8-Clang-Arm7-Debug-Android',
    'Build-Ubuntu-GCC-Arm7-Debug-Android',
    'Housekeeper-PerCommit',
    'Housekeeper-PerCommit-Trybot',
    'Perf-Android-GCC-Nexus7-GPU-Tegra3-Arm7-Release',
    'Perf-Android-GCC-Nexus5-GPU-Adreno330-Arm7-Release-Appurify',
    'Perf-Win8-MSVC-ShuttleB-GPU-HD4600-x86_64-Release-Trybot',
    'Test-Android-GCC-Nexus7-GPU-Tegra3-Arm7-Debug',
    'Test-ChromeOS-GCC-Link-CPU-AVX-x86_64-Debug',
    'Test-iOS-Clang-iPad4-GPU-SGX554-Arm7-Debug',
    'Test-Ubuntu-Clang-GCE-CPU-AVX2-x86_64-Coverage-Trybot',
    'Test-Ubuntu-GCC-GCE-CPU-AVX2-x86_64-Debug',
    'Test-Ubuntu-GCC-GCE-CPU-AVX2-x86_64-Release-TSAN',
    'Test-Ubuntu-GCC-ShuttleA-CPU-AVX-x86_64-Debug',
    'Test-Ubuntu-GCC-ShuttleA-GPU-GTX550Ti-x86_64-Release-Valgrind',
    'Test-Ubuntu-GCC-ShuttleA-GPU-GTX550Ti-x86_64-Debug-ZeroGPUCache',
]


def prettier_print(obj, indent, stream=sys.stdout, max_line_length=80):
  """Pretty-print the object, in a nicer format than pprint."""

  def _breakline(line):
    """Break the line to fit under N characters."""
    # If we're under the limit, just return.
    if len(line) <= max_line_length:
      return [line]

    # Dict entries.
    m = re.match(r'^(\s+)(.+): (.+)$', line)
    if m:
      return (_breakline(m.groups()[0] + m.groups()[1] + ':') +
              _breakline(m.groups()[0] + '    ' + m.groups()[2]))

    # List entries and dict keys.
    m = re.match(r"^(\s+)'(.+)'([:,])$", line)
    if m:
      prefix = m.groups()[0]
      content = m.groups()[1]
      max_len = max_line_length - len(prefix) - len("(''):")
      parts = []
      while len(content) > max_len:
        parts.append(content[:max_len])
        content = content[max_len:]
      parts.append(content)
      lines = _breakline(prefix + "('" + parts[0] + "'")
      for p in parts[1:-1]:
        lines.extend(_breakline(prefix + " '" + p + "'"))
      lines.extend(_breakline(prefix + " '" + parts[-1] + "')" + m.groups()[2]))
      return lines

  class LineBreakingStream(object):
    """Stream wrapper which writes line-by-line, breaking them as needed."""
    def __init__(self, backing_stream):
      self._backing_stream = backing_stream
      self._current_line = ''

    def _writeline(self, line):
      for l in _breakline(line):
        self._backing_stream.write(l + '\n')

    def write(self, s):
      self._current_line += s
      split = self._current_line.split('\n')
      for w in split[:-1]:
        self._writeline(w)
      self._current_line = split[len(split)-1]

    def flush(self):
      self._writeline(self._current_line)

  def _pprint(obj, indent, stream):
    indent_str = ' ' * indent
    if isinstance(obj, dict):
      stream.write('{\n')
      for k in sorted(obj.iterkeys()):
        stream.write(indent_str + '\'%s\': ' % k)
        _pprint(obj[k], indent + 2, stream=stream)
        stream.write(',\n')
      stream.write(' ' * (indent-2) + '}')
    elif isinstance(obj, list):
      stream.write('[\n')
      for v in obj:
        stream.write(indent_str)
        _pprint(v, indent + 2, stream=stream)
        stream.write(',\n')
      stream.write(' ' * (indent-2) + ']')
    elif isinstance(obj, basestring):
      stream.write('\'%s\'' % obj)
    elif isinstance(obj, bool):
      if obj:
        stream.write('True')
      else:
        stream.write('False')
    else:
      stream.write(obj)

  s = LineBreakingStream(stream)
  _pprint(obj, indent, stream=s)
  s.flush()


def main(buildbot_spec_path):
  """Generate a spec for each of the above bots. Dump them all to a file."""
  specs = {}
  tmp_spec_file = tempfile.NamedTemporaryFile(delete=False)
  tmp_spec_file.close()
  try:
    for bot in bots:
      subprocess.check_call(['python', buildbot_spec_path,
                             tmp_spec_file.name, bot])
      with open(tmp_spec_file.name) as f:
        spec = json.load(f)
      spec['dm_flags'] = ['--dummy-flags']
      spec['nanobench_flags'] = ['--dummy-flags']
      specs[bot] = spec
  finally:
    os.remove(tmp_spec_file.name)

  out = os.path.realpath(os.path.join(
      os.path.dirname(os.path.realpath(__file__)), os.pardir,
      'recipe_modules', 'skia', 'fake_specs.py'))

  with open(out, 'w') as f:
    f.write('''# This file is generated by the %s script.

FAKE_SPECS = ''' % sys.argv[0])
    prettier_print(specs, indent=2, stream=f)

  print 'Wrote output to %s' % out


if __name__ == '__main__':
  if len(sys.argv) != 2:
    print >> sys.stderr, ('Usage: %s <path_to_buildbot_spec_script>'
                          % sys.argv[0])
    sys.exit(1)
  main(*sys.argv[1:])
